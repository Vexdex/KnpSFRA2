# Consistent Collection Resources

To hook this up, let’s start with the test. And the test is going to be kind of cool because we’re actually going to make a get request for programmer and follow that link to the next battles. So in programmer controller test, create a new public function: test follow programmer battles link. On top of this first two parts of the test get programmer, that actually creates a programmer and makes the get request.

Okay, in this case, we’re going to need some battles in the database so that when we eventually get to that page, we can see some results. So first, create a project with this arrow: create project, cool project. And then let’s create three battles. And remember to do that, we just need the battle manager service. So we’ll say battle manager equals this get service, which is just a helper method on our base API test case, and look for battle dot battle manager. I'll put some PHP doc above that so that we get auto complete on the next lines. Perfect.

And now it’s pretty easy. We can say battle manager arrow battle, to create a battle between our programmer and make sure that you have a programmer variable set up above and our project. And I'll just copy that, paste it two more times so that we have three battles in the database. Okay, great.

With those three battles, we’re going to make a get request for our programmer. And when we get back, we should have a link that we can follow. So let’s get that – read that link with URI equals this arrow asserter, arrow read response property. And that will read underscore links dot battles, that new link that we just created on our entity. Make sure you pass response as the first argument.

Now we can just follow that. So I'm actually going to copy the response equals line from further above, and we still want to send our authorization header, but now the get request is going to be to our new, dynamic URI. Before we assert anything, let’s just dump that response because I'm going to fill some things in to kind of see how it looks and then make some decisions based on that. Perfect.

All right, in programmer controller test, let’s hook this up. It’s relatively straightforward. First, we need to exchange the nickname for a programmer object, because the programmer has a nickname property on it; we can use the magic param conversion by just typing in argument with programmer and it will query for programmer for us. 

Next, get battles the way you always do. This get doctrine, get repository [inaudible] [00:03:01] colon battle, and let’s use find by to find a collection that match the programmer equal to programmer. So in other words, find all battles that – where the programmer property’s equal to that programmer. And then it’s as simple as return. This arrow creates API response, passing in the battles, right? Should be that simple?

So let’s go back to our programmer controller test, copy that new method name. Let’s run over, do vendor, bin, PHB unit, dash dash filter with that method name. Okay, great. Now, check out how this looks. On the top level, you have a JSON array, and then inside of there you just have a bunch of battle objects. So at first glance, that’s perfect, right? Well, it might be perfect but it’s actually totally inconsistent with our other existing collection endpoint, and that is the endpoint that returns you all programmers in the system.

If you scroll down your test a little bit, your test programmers collection, you’ll remember that what we expect back is actually an items key. And then under the items, key, we have the array of all of the programmers. So now we have two collection endpoints. It’s not important that one of them is a subordinate’s resource of programmer. We have two collection resources that look different. That is not a good thing. We want all of our collection resources to have a consistent pattern.

So back in the test we’re working on right now, let’s add a new assert for this arrow, arrow assert response property exists for – on the response, for that same item. Because we want to change our response to be consistent with the other collection responses. Now, in programmer controller, the reason we go that items back before was because in our list action, we used pagination. We went onto this pagination factory and we created a special collection object. If you click that, what this does behind the scenes – and this is the really important part – is it created a paginated collection object? And ultimately, if you scroll down, that’s what was returned, and that paginated collection object is actually what goes into the serializer.

And the paginated collection object is something that we created. And very simply, you can see that it has an items key, along with a couple other keys like total, count, and the pagination links themselves. So if we want our endpoint to match that, every collection resource should always be a paginated collection object.

So first, let’s do this a very simple way, which is collection equals new paginated collection, and we’ll just pass at battles and then the total items, which of course is just going to be count of battles because we’re returning everything. We’re not actually doing pagination, but that’s okay; we’re just going to call this – use the paginated collection object. Then down here, well, pass it to the collection. So that should get our test passing.

And it does. And if you look at the dump, now, we have the items key, which is awesome, and we also have a total and account and we have the underscore links key, except that’s actually empty, now. Well, at this point if we’re going to all this trouble of using this paginated collection, even if we don’t necessarily think that we need pagination on this endpoint, we might as well add it. Because A) it’s going to be consistent with our other collection endpoints, and B) we’ve already done all the work for paginations so this is going to be super easy to hook up.

So change the collection equals line to this arrow get pagination factory, that service that we were just looking at a second ago, arrow create collection. Now, this needs three arguments – this needs a few arguments. The first two important ones are the query builder and the request. So instead of actually making this full query for battles, we need to turn this into a query builder. So rename this to a new method called create query builder for programmer, and pass it the programmer object. And I'll hold command, and I'll click battle to go into the battle repository. And in here, we’ll create that public function: create query builder for programmer. It will take any programmer arguments.

Now, this is going to be a really simple return, this arrow: create query builder, battle and where, battle dot programmer equals colon programmer, and then make sure you set the parameter of programmer set to that programmer object, and that’s it. So that’s a nice query builder that will return to us all the battles for this specific programmer.

Now, back in program controller, you can rename that variable to battles query builder, pass that as our first argument. Second argument is the request object, so you guys know how to get that. Let’s type in the argument with request. Now we’ve got that. And the last two arguments are the name of the routes that the pagination links should point to. So obviously, that’s this route. API programmers battles questions. And the last argument is any route parameters that need to be passed to that route, and this one actually has a nickname. So make an array with nickname equal to programmer arrow get nickname, and that’s it. So we basically just changed this one line to create an actual paginated collection, and now we can celebrate. Rerun the test.

That is real pagination pretty much out of the box for us, there. Of course, this only has three results so we really only have one page. But eventually, if this programmer keeps having battles, then we’re gonna be all set with pagination out of the box. And if nothing else, that’s really good for consistency.
