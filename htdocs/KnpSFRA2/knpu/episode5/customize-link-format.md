# Customize Link Format

As cool as all this HAL JSON stuff is, ultimately you need to build your API for whoever’s using it. And that might be ReactJS app, or it might be a mobile app you’re building, or it might be third party clients that have differing technical expertise. And honestly, how JSON in a lot of the formats that are trying to be standardized, are not necessarily that useful. This underscore embedded thing here, honestly to me, is just ugly. 

I also don’t really like having this href. So let’s suppose that we’re building maybe a Java Script front end, and it would just work better if we didn’t hide our links under this Href, or if we just had the name of the link and then the URL next to it. Let’s take control of our application and make that happen. Here’s how you do it. The HATEOAS library that we installed really just helps us add link relations. And there are two link relations that are actual links and that are also embedded relations. And there’s a really easy way to control exactly how those are added to your response.

In app bundle, in the serializer directory, create a new class called custom HATEOAS JSON serializer. And make it extend a class called JSON HAL serialize. That’s the current class from that library that’s adding the links in just the format that we’ve been seeing. In fact, if you look at JSON HAL Serializer, it has two methods in it; serialize links, which is responsible for reading the link annotations that we have and adding them to our response – with underscore links – and also serialized embeds, which does the same thing for the embedded objects and ultimately adds things under the underscore embedded.

So let’s not worry about embedded; let’s worry just about underscore links. So I'm going to command end, co-generate, go to override methods in overrides serialized links. And we’re going to make this really simple. Create a new serialized links array. And you can go back to the parent class. Let’s actually copy the PHP deck from the interface, because that will give us really good auto completion above this method. All right, this will be really simple.

Then auto complete, that links so we get the U statement. Okay, this will be really simple. Create a serialized links array and for each over the links variable, which is an array of linked objects, and then we’ll just create the format we want, underscore links. Which is going to be serialized links. And then for the key of each, we will of course use link arrow get REL, like programmer or sell, and then, instead of sending that to an array with an href key, we’ll just set that to link arrow get Href and that’s it. And to add that to our representation, this is going to be very similar to something we did earlier when we created our own custom link annotation. We’re going to do visitor arrow add data underscore links, pass it the serialized links. With any luck, that should give us a simpler format without that Href.

All right, to hook this up, you guys can probably guess what we’re going to do. Go to app config services dot YML and register this as a service. The name doesn’t matter, so how about custom HATEOAS JSON serializer. It said it’s class two, that same thing. We don’t have any construct to arguments yet so we’re good there.

Now finally, copy that method name but we just need to tell the bundle to use our serializer instead of the normal serializer, and that’s done in config dot YML under the bundle. Without even looking at the documentation, we can get a list of the configuration under this bundle by going to our console and running bin console debug colon config. When you do that, you’ll see that there’s an option – a new, valid configuration key called bazinga underscore HATEOAS. So pass that in, this time. And now we can see the configuration for this bundle and you can very clearly see Bazinga HATEOAS serializer JSON and this is where we’re going to pass our service name.

So add Bazinga HATEOAS, serializer, JSON and then paste our service name. With any luck, that should do it. Before we run our test, though, we already know a couple things are going to be broken. So in valid controller test, take off the Href because once again, it should just be underscore links dot programmer. Also open up programmer controller test, and under test get program, we’re going to have make the same change. Take off the Href. Okay. That’s a lot of changes, so let’s go back and actually rerun our entire test suite.

Awesome, it passes. I think I still have a D bug response in there somewhere but that’s nothing to worry about; we’re green. And we’ve taken control of hour our response looks in a way that’s convenient for our clients. You notice something else that I don’t like? In battle controller tests where we added the embedded link, it’s hidden under this ugly underscore embedded key. Now, originally we had decided to make a programmer key in the output just equal to the nickname of the programmer. And then later, we added this little embedded object. Well, let’s suppose that we found out that our API client really does want the entire programmer object but they don’t want it hidden under this ugly embedded key. They want it just on the root of the data like it always was.

Well, that’s fine. We can just stop using the embedded functionality from this bundle. So delete the assert that just looks for the string, and instead let’s assert that programmer dot nickname is equal to Fred. So in other words, the programmer key is going to be the entire object, not just the nickname. Now, in battle dot PHB, take off the embedded key so it will no longer add the underscore embedded key to the response. And then down below, for programmer, just add the at expose that the other fields have in the API. And remember, we originally didn’t expose that because we were doing this cool virtual property thing down here so that programmer was just equal to the nickname. Well, let’s get rid of that now because we want programmer to be equal to the entire response.

Back in battle controller test to see that this is all working, I am going to debug my response. And let’s copy that map name and give this guy a try. Vendor bin PHB unit dash dash filter. Oh, and it actually explodes with “warning, call user funk parameter won’t accept to be bad. Call back battle does not have a method. Get programmer nickname.” I was a little too aggressive. You’ll remember at the top of battle dot PHB we’re using the expression object dot get programmer nickname, inside of our parameter. So I'm actually going to undo this change, put back my get programmer nickname but we’ll take off the virtual property so that it’s not actually exposed in the end output. All right, go back, run the test again, and now we’re green and we can print it out. Looks exactly how we want. So we have the embedded programmer; I've just decided that for my client, it’s better to have it not under the underscore embedded key. And guess what, guys? We’re starting to break the rules, and that’s okay. Please do that. But we’re no longer truly returning an application slash how plus JSON format. 

We’re bending and inventing our own rules. And when you do that, it’s good to advertise that. And the way you do that is by creating a new content site. And it usually follows this format: VND standing for vendor, dot and then the name of your application, like code battles. So this tells me it’s still JSON but it’s some custom vendor format so probably we’re going to need to add some extra documentation to our API that explains how to expect the links and embedded data to come back.

So let’s copy that and go into programmer controller test and update our cert equals. That’s checking for the content type property. And finally, copy that method name and let’s make sure everything is looking good with our new custom content type. And it is. So the moral of the story is I really love this HATEOAS library because it’s a great way to add links to your response. But it doesn’t mean that you have to live with the how format that it uses by default. You can use a different official format or you can invent your own format.
